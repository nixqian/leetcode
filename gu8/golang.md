# golang 八股整理
## 指针
32位机器和64位机器，分别占4 / 8 byte  = 32 / 64 bit
## 什么是协程
协程是用户态轻量级线程，它是线程调度的基本单位。通常在函数前加上go关键字就能实现并发。一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会自动伸缩， 因此可以轻易实现成千上万个goroutine同时启动。
## 高效拼接字符串
"+": 使用+操作符进行拼接时，会对字符串进行遍历，计算并开辟一个新的空间来存储原来的两个字符串。
fmt.Sprintf: 由于采用了接口参数，必须要用反射获取值，因此有性能损耗。
strings.Builder: 用WriteString()进行拼接，内部实现是指针+切片，同时String()返回拼接后的字符串，它是直接把[]byte转换为string，从而避免变量拷贝。
bytes.Buffer:bytes.Buffer是一个一个缓冲byte类型的缓冲器，这个缓冲器里存放着都是byte, bytes.buffer底层也是一个[]byte切片。
strings.join: 基于strings.builder来实现的,并且可以自定义分隔符，在join方法内调用了b.Grow(n)方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效。

性能: strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf

## rune类型
type rune = int32
ASCII 7bit 表示英文
Unicode 表示所有字符
字符串底层是 byte, 非rune
中文UTF-8, 每个中文3byte
获取中文的长度:
len([]rune(s))
utf8.RuneCountInString(s)

## init 什么时候执行
在main函数运行之前
详细：
init()函数是go初始化的一部分，由runtime初始化每个导入的包，
初始化不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。
每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的init()函数。同一个包，甚至是同一个源文件可以有多个init()函数。init()函数没有入参和返回值，不能被其他函数调用，同一个包内多个init()函数的执行顺序不作保证。
执行顺序：import –> const –> var –>init()–>main()
一个文件可以有多个init()函数！

## 如何知道一个对象是分配在栈上还是堆上？
## 内存逃逸分析
-gcflags=-m 可以查看逃逸情况
### 1. 指针逃逸
函数返回一个新建对象的指针，函数执行完后不能回收对象，所以要分配在堆上
### 2. interface 动态类型逃逸
编译期间很难确定其参数的具体类型
### 3. 栈空间不足
初始分配2k的栈空间，机器限制栈空间最大8M(8192), 8193的时候会逃逸
### 4. 分配的大小不确定
make([]int, n)
### 5. 闭包

## 如何利用逃逸分析提升性能
传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。
一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。

## interface的比较
interface的type相等 且 value 相等
两个interface都是unset的nil

## 两个nil不相等
主要是类型不同, 具体类型的nil和interface的nil, interface{} 未确定类型

## 函数返回局部变量的指针是否安全？
安全，因为逃逸分析，局部变量返回指针的情况，会分配内存到堆上

## slice 扩容
go1.17: 容量1024前, 2倍扩容，之后1.25倍扩容; 但是会进行内存对齐(做查表)
go1.18: 

## 垃圾清理
### 1.3 标记清除法
1. stw 停止程序的业务逻辑运行， 从main函数开始扫描可达的内存和不可达的内存占用
2. 标记，可达的内存标记
3. 清除没有标记的内存
4. 结束stw
重复上述直到main函数退出
优化：停止stw后再进行垃圾回收
缺点：stw时间长

### 1.5三色标记法 + 插入写屏障
- 初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤 3，直到灰色对象全部变黑色。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
- 收集所有白色对象（垃圾）
### 插入写屏障 （强三色不变性：）黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。
gc开始标记阶段时，开启写屏障。引用发生时，如果被引用对象是白色，则设置为灰色
- (新对象)用户新创建的对象，直接被标记为灰色，避免了错误回收；
- (修改引用)当白色对象的父节点从灰色对象改为黑色对象时，该对象被标记为灰色，也避免了错误回收。
- 消耗：栈上对象被置黑后，为了避免错误回收，要么需要对栈上对象加入写屏障（频繁操作开销增加），要么需要重新扫描栈（STW）。
- Go在1.5版本至1.7版本，开启插入写屏障后，只对堆上的指针变动进行置灰，而对于栈上的指针不作更改；标记完成后的STW，会对栈上的白色对象重新进行一次标记。
- Go从1.5以前每次STW耗时从~100ms降低到了该阶段所需要花费的~10ms。
### 策略：
栈：不开启写屏障，会在回收前重新扫描一遍（stw）
堆: 开启写屏障，并行回收

### 删除写屏障
对象的引用被删除时，如果该对象是白色，则该对象被置为灰色。代码示例如下：
删除写屏障的可靠性来源于其满足弱三色不变性：
黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径
### 1.8 三色标记+混合写屏障
Go 1.8之后为什么还需要STW？
还有两个阶段需要STW：
GC开始前的准备工作，例如设置写屏障；
标记结束时，重新扫描全局变量、扫描系统栈、结束标记过程等。
golang GC 步骤
1. mark阶段
    1.1 Mark Prepare 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等，这个过程需要STW。
    1.2 GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行。
2. Mark Termination阶段：该阶段主要是完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，这个过程也是会STW的。
3. Sweep: 按照标记结果回收所有的白色对象，该过程后台并行执行。
4. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。

### GC的触发时机
1. 一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量 GOGC，之后堆内存达到上一次垃圾收集的 2 倍时才会触发 GC。
2. 二是如果一定时间内没有触发，就会触发新的循环，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。
3. 可以手动调用GC runtime.GC()

##  GPM 调度 和 CSP 模型
参考：![zhihu](https://zhuanlan.zhihu.com/p/323271088)
### CSP 模型：
CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通过共享内存来通信。用于描述两个独立的并发实体通过共享的通讯 channel (管道)进行通信的并发模型。
### GPM 调度
#### 进程与线程
进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB
一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。
内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)".
1. N:1 n个协程对应1个线程
优点：优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速
缺点：
  - 1个进程的所有协程都绑定在1个线程上
  - 某个程序用不了硬件的多核加速能力
  - 一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。
2. 1:1 一个协程对应一个线程
优点: 
  - 容易实现
  - 协程的调度都由CPU完成了，不存在N:1缺点，
缺点：
  - 协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。
3. M:N M个协程绑定N个协程
优点：前两者的结合，没有上述缺点
缺点：实现复杂
#### go语言的写成 gorouting, channel
占用内存小，一个goroutine只占几KB，但是可扩展
调度灵活，go的runtime调度
#### 2012之前的调度器
G 协程， M 线程
调度器维护全局G队列，M要执行、放回G都要访问全局队列，需要加锁互斥
缺点：
  - 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争
  - M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M'。
  - 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。
#### 新调度器
G gorouting M threading P Processor
Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。
##### GMP模型
在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。
![GMP模型](images/golang_gmp.webp)
- 全局队列（Global Queue）：存放等待运行的G。
- P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
- P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。
- M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。

P和M的数量问题
- P的数量：由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。
- M的数量：
  - go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
  - runtime/debug中的SetMaxThreads函数，设置M的最大数量
  - 一个M阻塞了，会创建新的M。
M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。

P和M何时创建
- P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。
- M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

##### 调度器的设计策略
复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
  - work stealing机制： 当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
  - hand off机制: 当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。
利用并行：
  - GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。
抢占：
  - 在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。
全局G队列：
  - 在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。

##### go func 的调度流程
![gofunc过程](/images/golang_gmp_gofunc.webp)
1. 我们通过 go func()来创建一个goroutine；
2. 有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；
3. G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；
4. 一个M调度G执行的过程是一个循环机制；
5. 当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；
6. 当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。

## channal的原理
### 结构定义
```
type hchan struct {
 qcount   uint  // 队列中的总元素个数
 dataqsiz uint  // 环形队列大小，即可存放元素的个数
 buf      unsafe.Pointer // 环形队列指针
 elemsize uint16  //每个元素的大小
 closed   uint32  //标识关闭状态
 elemtype *_type // 元素类型
 sendx    uint   // 发送索引，元素写入时存放到队列中的位置

 recvx    uint   // 接收索引，元素从队列的该位置读出
 recvq    waitq  // 等待读消息的goroutine队列
 sendq    waitq  // 等待写消息的goroutine队列
 lock mutex  //互斥锁，chan不允许并发读写
}

```
### 读写流程
向 channel 写数据:
1. 若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。
2. 若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。
3. 若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。

从 channel 读数据
1. 若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。
2. 如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。
3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。
4. 将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。

关闭 channel
1. 关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。
2. panic 出现的场景还有：
  - 关闭值为 nil 的 channel
  - 关闭已经关闭的 channel
  - 向已经关闭的 channel 中写数据

### 无缓冲 Chan 的发送和接收是否同步?
// 无缓冲的channel由于没有缓冲发送和接收需要同步
ch := make(chan int)   
//有缓冲channel不要求发送和接收操作同步
ch := make(chan int, 2)  

## context
### 用途
Context（上下文）是 Golang 应用开发常用的并发控制技术 ，它可以控制一组呈树状结构的 goroutine，每个 goroutine 拥有相同的上下文。Context 是并发安全的，主要是用于控制多个协程之间的协作、取消操作。
### 数据结构
Context 只定义了接口，凡是实现该接口的类都可称为是一种 context。
```
type Context interface {
   Deadline() (deadline time.Time, ok bool)
   Done() <-chan struct{}
   Err() error
   Value(key interface{}) interface{}
}
```
「Deadline」 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。
「Done」 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。
「Err」 方法：返回 Context 被取消的原因。
「Value」 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。

## map
## sync.Map


## defer 和 return
### return
return 是会把结果赋值到返回值，返回值可能保存在当前栈空间(未命名的返回值)，也可能保存在调用者的栈空间(命名的返回值)
### defer执行顺序
return 赋值完返回值后, defer进行出栈，先进后出(栈)
### return的执行过程
先返回值赋值，在全部执行完后，执行ret指令，退出函数栈