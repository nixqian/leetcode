# 数据类型
基础: string, list, set, zset, hash
高级数据类型: 
  - bitmap: 基于string, 最大长度512M, getbit, setbit, bitcount  512 * 1024 * 1024 * 8 = 42亿+
  - HyperLogLog: 基数统计（集合中元素去重的个数），每个键12k，不存内容，12 * 1024 * 8
    - pfadd 加入集合，如果结果变了返回1
    - pfcount 获取近似的基数值
    - pfmerge 合并连个键
  - GeoHash: 附近的店，附近的人等等。 
    - GEOADD 添加经纬度坐标到集合中
    - GEODIST 获取集合中两个成员的距离
    - GEOHASH 获取成员的geohash
    - GEOPOS 获取集合中成员的经纬度坐标
    - GEORADIUS 根据经纬度获取给定半径内的成员列表
    - GEORADIUSBYMEMBER 根据成员获取给定半径内的成员列表
  - bloomFilter: redis 4.0 的module
    - bitmap + 多个hash (h1()->1, h2()->2, h3()->5)
    - bfadd, bfexist, bfmadd, bfmexist
# 雪崩、击穿、穿透
## 雪崩
大量缓存同时失效，1 redis挂了 2 过期时间设置问题
缓存问题解决：
1. 缓存高可用，redis集群，哨兵机制
2. 数据随机过期时间，防止同时失效
容灾：
1. 前端限流
2. 数据库分库分表，读写分离，提高容灾能力
## 击穿：
某些热点key，失效的时候，有大量请求打到db (1是失效问题，2是大量请求到db问题)
1. 如果可以的话，热点数据不设置失效时间，担心数据变更的话可以用主动缓存主动更新缓存
2. 缓存失效的情况下，使用互斥锁来防止全部请求都到db上，让一个线程访问db并重新更新缓存(性能变差)
## 穿透：
查询不存在的数据，缓存没有、数据库也没有。可能是一些攻击
解决：
1. 参数校验，减少防止非法请求的影响
2. 如果是黑客攻击，考虑对ip限制频率或者封禁
3. 把不存在的key也存进redis，如果是随机的，这种方法无效
4. 布隆过滤器，先通过布隆过滤器判断key是否存在
### 扩展：布隆过滤器
概念：一个很长的二进制串，对key进行hash，将对应位置的二进制位置为1；查询时判断hash值对应的位置是否为1
因为hash有碰撞，所以布隆过滤器可以判断某个key一定不存在，不能判断一定存在
优点：内存占用少，插入和查询都很快
缺点：不能判断数据一定存在，数据大的时候误判会增加；不能删除数据
#### 实现1: redis-bitmap
set k1 'big'  // 初始化
setbit k1 7(某一位) 1(0/1) // 设置某一位
getbit k1 7  // 获取某一位
bitcount k1 [start end] // 字节start到end为止1的个数
#### 实现2: RedisBloom
Redis 4.0 版本之后，布隆过滤器才作为插件被正式使用。布隆过滤器需要单独安装
bf.add	只能添加元素到布隆过滤器。
bf.exists	判断某个元素是否在于布隆过滤器中。
bf.madd	同时添加多个元素到布隆过滤器。
bf.mexists	同时判断多个元素是否存在于布隆过滤器中。
bf.reserve	以自定义的方式设置布隆过滤器参数值，共有 3 个参数分别是 key、error_rate(错误率)、initial_size(初始大小)。

# 分布式锁
## 要求：
互斥性: 任意时刻，只有一个客户端能持有锁。
锁超时释放：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。
可重入性:一个线程如果获取了锁之后,可以再次对其请求加锁。
高性能和高可用：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。
安全性：锁只能被持有的客户端删除，不能被其他客户端删除
## 方案：
### 方案一：SETNX + EXPIRE
缺点：两条命令，非原子操作，expire失败导致其他线程拿不到锁
### 方案二：SETNX + value值是（系统时间+过期时间）
setnx k1 "系统时间+过期时间", 拿不到的时候，取值校验是否过期
优点：规避了expire导致的永久锁问题
缺点: 1. 过期时间，需要客户端时间同步 2. 锁过期后，并发来请求锁，多个线程都执行getset, 虽然最后只有一个能抢到锁，但是过期时间可能被覆盖 3. 锁可能被别的客户端释放
### 方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)
使用lua脚本 把setnx和expire变成原子操作
缺点：
### 方案四：SET的扩展命令（SET EX PX NX）
SET key value[EX seconds][PX milliseconds][NX|XX]
NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。
EX seconds :设定key的过期时间，时间单位是秒。
PX milliseconds: 设定key的过期时间，单位为毫秒
XX: 仅当key存在时设置值

问题一：锁过期释放了，业务还没执行完。假设线程a获取锁成功，一直在执行临界区的代码。但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。
问题二：锁被别的线程误删。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完呢。

### 方案五：SET EX PX NX  + 校验唯一随机值,再释放锁
问题：还是可能存在锁过期释放，业务没执行完的问题
### 方案六: 开源框架:Redisson
### 方案七：多机实现的分布式锁Redlock

# 大key，热key
## 大key
大key是指当redis的字符串类型占用内存过大或非字符串类型元素数量过多。
string类型的key超过10KB
hash/set/zset/list等数据结构中元素个数大于5k/整体占用内存大于10MB
不同系统性能条件不同，所以建议这个标准设置保守些，以系统稳定性为第一考量
### 危害
客户端执行命令的时长变慢
Redis内存达到maxmemory参数定义的上限引发操作阻塞或重要的Key被逐出，甚至引发内存溢出（Out Of Memory）。
集群架构下，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡。
对大Key执行读请求，会使Redis实例的带宽使用率被占满，导致自身服务变慢，同时易波及相关的服务。
对大Key执行删除操作，易造成主库较长时间的阻塞，进而可能引发同步中断或主从切换。
### 发现
增加内存&流量&超时等指标监控
bigkeys命令
redis-rdb-tools: 使用redis-rdb-tools离线分析工具来扫描RDB持久化文件，虽然实时性略差，但是完全离线对性能无影响。
集成化可视化工具
### 解决
1. 删除：当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。
当Redis版本小于4.0时，避免使用阻塞式命令KEYS，而是建议通过SCAN命令执行增量迭代扫描key，然后判断进行删除。
2. 压缩和拆分key
当vaule是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。
当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。
当value是list/set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。

## 热key
某个key访问量特别高，如果是集群模式，导致流量不平衡